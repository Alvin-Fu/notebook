[原文链接](https://dr-knz.net/go-calling-convention-x86-64.html)
## 简介：
本文分析go的编译器如何在x86-64目标中生成方法调用，参数传递和异常处理的代码。
这里没有分析编译器如何在内存中分配数据(函数的参数和返回值除外)、逃逸分析是怎么工作的、为什么编译器必须适应异步的垃圾回收器以及goroutine的处理如何影响代码的生成。
本文中的所有的代码都是使用freebsd/amd64目标go1.10.3执行的。汇编代码是使用`go tool objdump`生成的并且使用的是go的汇编语法。

## 参数、返回值和调用顺序
### 参数和返回值
**如何传递参数给函数并返回结果呢？**
让我们看一下这个简单的方法：
`func EmptyFunc() {}`
他的汇编代码：
```
EmptyFunc:
     0x480630              c3                      RET
```


在加一个返回值时：
`func EmptyFunc()int{	return 123 }`
他的汇编代码：
```
FuncConst:
  0x480630              48c74424087b000000      MOVQ $0x7b, 0x8(SP)
  0x480639              c3                      RET
```
对比汇编代码我们可以看到返回值是通过栈进行传递的，而不像大多数的原生的编译语言标准x86-64调用约定使用寄存器。
**对比C或者C++的汇编输出：**
```
FuncConst:
      movl    $123, %eax
      retq
```
这是将返回值传递到寄存器中

**如何做一个简单的参数传递的go方法？**
```
// Note: substracting z so we know which argument is which.
func FuncAdd(x,y,z int) int {
	return x + y - z 
}
```
汇编代码：
```
FuncAdd:
  0x480630              488b442408              MOVQ 0x8(SP), AX  // get arg x
  0x480635              488b4c2410              MOVQ 0x10(SP), CX // get arg y
  0x48063a              4801c8                  ADDQ CX, AX       // %ax <- x + y
  0x48063d              488b4c2418              MOVQ 0x18(SP), CX // get arg z
  0x480642              4801c8                  SUBQ CX, AX       // %ax <- x + y - z
  0x480645              4889442420              MOVQ AX, 0x20(SP) // return x+y-z
  0x48064a              c3                      RET
```
从上面可以看到函数的参数也是通过堆栈进行传递，而不是像其他语言那样通过寄存器。
我们可以看到参数是在堆栈的顶部，而返回值则位于堆栈的底部。
**对比C和C++的汇编代码：**
```
FuncAdd:
      leal    (%rdi,%rsi), %eax
      subl    %edx, %eax
      retq
```
可以看到参数是通过寄存器进行传递。准确的数量依赖于调用约定，但是在freebsd/amd64下最多可以在寄存器中传递6个参数，其他的参数都必须在堆栈中。
注意：在go的公开提议中使用寄存器进行参数传递`https://github.com/golang/go/issues/18597`。但是没有被官方采纳。

### 函数的调用：一个函数是如何被调用的？
如何将上面的函数FuncAdd调用的？
```
func DoCallAdd() int { return FuncAdd(1, 2, 3) }
```
**汇编代码：**
```
0x480650              64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
0x480659              483b6110                CMPQ 0x10(CX), SP
0x48065d              7641                    JBE 0x4806a0
0x48065f              4883ec28                SUBQ $0x28, SP
0x480663              48896c2420              MOVQ BP, 0x20(SP)
0x480668              488d6c2420              LEAQ 0x20(SP), BP
0x48066d              48c7042401000000        MOVQ $0x1, 0(SP)
0x480675              48c744240802000000      MOVQ $0x2, 0x8(SP)
0x48067e              48c744241003000000      MOVQ $0x3, 0x10(SP)
0x480687              e8a4ffffff              CALL src.FuncAdd(SB)
0x48068c              488b442418              MOVQ 0x18(SP), AX
0x480691              4889442430              MOVQ AX, 0x30(SP)
0x480696              488b6c2420              MOVQ 0x20(SP), BP
0x48069b              4883c428                ADDQ $0x28, SP
0x48069f              c3                      RET
0x4806a0              e80ba5fcff              CALL runtime.morestack_noctxt(SB)
0x4806a5              eba9                    JMP src.DoCallAdd(SB)
```
这里有做了上面事情？
在这个函数的中心我们看到了我们想看到的：
```
0x48066d              48c7042401000000        MOVQ $0x1, 0(SP)     // set arg x
0x480675              48c744240802000000      MOVQ $0x2, 0x8(SP)   // set arg y
0x48067e              48c744241003000000      MOVQ $0x3, 0x10(SP)  // set arg z
0x480687              e8a4ffffff              CALL src.FuncAdd(SB) // call
0x48068c              488b442418              MOVQ 0x18(SP), AX    // get return value of FuncAdd
0x480691              4889442430              MOVQ AX, 0x30(SP)    // set return value of DoCallAdd
```
函数被调用之前，参数会被压栈，在被调用后，从被调用帧中检索返回值并复制到调用帧中。
但是，我们已经知道了函数在被调用的之前参数是会被压栈的，这个意味者其他函数要想调用其他函数的时候就必须确保有足够的栈空间来进行函数调用。下面的代码就是在腾出栈空间并恢复：
```
// Before the call: make space for callee.
0x48065f              4883ec28                SUBQ $0x28, SP
// After the call: restore stack pointer.
0x48069b              4883c428                ADDQ $0x28, SP
```
剩下的是什么呢？
由于go是存在panic的因此必须保持运行时系统展开堆栈的能力。对于每一个被激活记录中就必须保存他的入口的堆栈指针和被调用的堆栈指针之间的差异。这一类型的指针是被存放在BP寄存器中，正是我们看到的汇编代码：(这块说的就是恢复现场是如何做到的)
```
// Store the frame pointer of the caller into a known location in
// the current activation record.
0x480663              48896c2420              MOVQ BP, 0x20(SP)
// Store the address of the copy of the parent frame pointer
// into the new frame pointer.
0x480668              488d6c2420              LEAQ 0x20(SP), BP
```
这就是一个约定的格式，即BP中总是指向了一个帧指针的链表，其中BP的每一个连续值总是比当前帧（SP+0x20）的堆栈指针多32个字节。通过这种方式堆栈总是可以对成功的扩展。
最后一段代码又代表什么呢？
```
0x480650              64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
0x480659              483b6110                CMPQ 0x10(CX), SP
0x48065d              7641                    JBE 0x4806a0
...
0x4806a0              e80ba5fcff              CALL runtime.morestack_noctxt(SB)
0x4806a5              eba9                    JMP src.DoCallAdd(SB)
```
go的runtime使用小堆栈作为一个优化：这也意味者一个goroutine总是以一个最小的堆栈开始，因此在一个运行的go程序中是可以同时跑很多的goroutine。然而，这也意味者在标准的小堆栈中不能递归的调用更多的函数，这样可能会导致崩溃。
因此在go中，每一个需要在堆栈上有激活记录的函数首先需要去检查当前goroutine的堆栈是否足够的大。通过比较当前goroutine的低位标记和当前的堆栈指针来实现的，低位标记存储在goroutine结构的偏移量16位（0x10）处，他总是可以被找到通过0xfffffff8

**比较C/C++中DoCallAdd如何工作的？**
```
DoCallAdd:
      movl    $3, %edx
      movl    $2, %esi
      movl    $1, %edi
      jmp     FuncAdd
```
这个参数的传递是在寄存器中，然后通过jmp-尾部调用将控制权转移给被调用者。这是有效的，因为FuncAdd的返回值变成了DoCallAdd的返回值。
堆栈指针是什么呢？可以看到DoCallAdd在C中不能告诉我们更多的信息，因为与go相反，他没有任何变量被保存在堆栈上，因此确实需要一个活动记录。一般来说如果不需要保存活动记录，也就不需要设置或者调整堆栈指针。
那么如果才能让C/C++的编译器保存一个活动记录呢？我们可以这样：
```
void other(int *x);
int DoCallAddX() { int x = 123; other(&x); return x; }
```
汇编代码：
```
DoCallAddX:
     subq    $24, %rsp       // make space
     leaq    12(%rsp), %rdi  // allocate x at address rsp+12
     movl    $123, 12(%rsp)  // store 123 into x
     call    other           // call other(&x)
     movl    12(%rsp), %eax  // load value from x
     addq    $24, %rsp       // restore stack pointer
     ret
```
可以看到%rsp是在函数进入是被设置，在函数结尾是被恢复。
那么异常处理呢？

## C/C++中的异常处理
上面的程序是被支持异常的C/C++编译器生成的。一般情况下编译器是不能确保被调用着不抛出异常的。然而在上面的代码中我们没有看到任何关于保存堆栈指针或者设置帧指针的内容。那么C/C++是如何在运行时处理堆栈展开的呢？

在ABI(应用程序二进制接口)中主要有两种方法实现异常传播的：
- “动态注册”，每一个激活记录中都有帧指针，组织成一个链表。这个可以使得堆栈展开的快速，在每个函数调用其他的函数的时候都有设置帧指针的开销。这个容易实现。
- 表格控制，编译器和汇编器在代码的旁边创建数据结构用于指示代码的记录对应的激活记录的大小。在GUN的工具链中这个被称为调用帧信息数据(CFI)。当一个异常被产生时，将

















