[原文链接](https://dr-knz.net/go-calling-convention-x86-64.html)
## 简介：
本文分析go的编译器如何在x86-64目标中生成方法调用，参数传递和异常处理的代码。
这里没有分析编译器如何在内存中分配数据(函数的参数和返回值除外)、逃逸分析是怎么工作的、为什么编译器必须适应异步的垃圾回收器以及goroutine的处理如何影响代码的生成。
本文中的所有的代码都是使用freebsd/amd64目标go1.10.3执行的。汇编代码是使用`go tool objdump`生成的并且使用的是go的汇编语法。

## 参数、返回值和调用顺序
### 参数和返回值
**如何传递参数给函数并返回结果呢？**
让我们看一下这个简单的方法：
`func EmptyFunc() {}`
他的汇编代码：
```
EmptyFunc:
     0x480630              c3                      RET
```


在加一个返回值时：
`func EmptyFunc()int{	return 123 }`
他的汇编代码：
```
FuncConst:
  0x480630              48c74424087b000000      MOVQ $0x7b, 0x8(SP)
  0x480639              c3                      RET
```
对比汇编代码我们可以看到返回值是通过栈进行传递的，而不像大多数的原生的编译语言标准x86-64调用约定使用寄存器。
**对比C或者C++的汇编输出：**
```
FuncConst:
      movl    $123, %eax
      retq
```
这是将返回值传递到寄存器中

**如何做一个简单的参数传递的go方法？**
```
Copy
// Note: substracting z so we know which argument is which.
func FuncAdd(x,y,z int) int {
	return x + y - z 
}
```
汇编代码：
```
FuncAdd:
  0x480630              488b442408              MOVQ 0x8(SP), AX  // get arg x
  0x480635              488b4c2410              MOVQ 0x10(SP), CX // get arg y
  0x48063a              4801c8                  ADDQ CX, AX       // %ax <- x + y
  0x48063d              488b4c2418              MOVQ 0x18(SP), CX // get arg z
  0x480642              4801c8                  SUBQ CX, AX       // %ax <- x + y - z
  0x480645              4889442420              MOVQ AX, 0x20(SP) // return x+y-z
  0x48064a              c3                      RET
```
从上面可以看到函数的参数也是通过堆栈进行传递，而不是像其他语言那样通过寄存器。
我们可以看到参数是在堆栈的顶部，而返回值则位于堆栈的底部。
**对比C和C++的汇编代码：**
```
FuncAdd:
      leal    (%rdi,%rsi), %eax
      subl    %edx, %eax
      retq
```
可以看到参数是通过寄存器进行传递。准确的数量依赖于调用约定，但是在freebsd/amd64下最多可以在寄存器中传递6个参数，其他的参数都必须在堆栈中。
注意：在go的公开提议中使用寄存器进行参数传递`https://github.com/golang/go/issues/18597`。但是没有被官方采纳。

### 函数的调用：一个函数是如何被调用的？
如何将上面的函数Func








