[原文链接](https://dr-knz.net/go-calling-convention-x86-64.html)
## 简介：
本文分析go的编译器如何在x86-64目标中生成方法调用，参数传递和异常处理的代码。
这里没有分析编译器如何在内存中分配数据(函数的参数和返回值除外)、逃逸分析是怎么工作的、为什么编译器必须适应异步的垃圾回收器以及goroutine的处理如何影响代码的生成。
本文中的所有的代码都是使用freebsd/amd64目标go1.10.3执行的。汇编代码是使用`go tool objdump`生成的并且使用的是go的汇编语法。

## 参数、返回值和调用顺序
### 参数和返回值
**如何传递参数给函数并返回结果呢？**
让我们看一下这个简单的方法：
`func EmptyFunc() {}`
他的汇编代码：
```
EmptyFunc:
     0x480630              c3                      RET
```


在加一个返回值时：
`func EmptyFunc()int{	return 123 }`
他的汇编代码：
```
FuncConst:
  0x480630              48c74424087b000000      MOVQ $0x7b, 0x8(SP)
  0x480639              c3                      RET
```
对比汇编代码我们可以看到返回值是通过栈进行传递的，而不像大多数的原生的编译语言标准x86-64调用约定使用寄存器。
**对比C或者C++的汇编输出：**
```
FuncConst:
      movl    $123, %eax
      retq
```
这是将返回值传递到寄存器中

**如何做一个简单的参数传递的go方法？**
```
// Note: substracting z so we know which argument is which.
func FuncAdd(x,y,z int) int {
	return x + y - z 
}
```
汇编代码：
```
FuncAdd:
  0x480630              488b442408              MOVQ 0x8(SP), AX  // get arg x
  0x480635              488b4c2410              MOVQ 0x10(SP), CX // get arg y
  0x48063a              4801c8                  ADDQ CX, AX       // %ax <- x + y
  0x48063d              488b4c2418              MOVQ 0x18(SP), CX // get arg z
  0x480642              4801c8                  SUBQ CX, AX       // %ax <- x + y - z
  0x480645              4889442420              MOVQ AX, 0x20(SP) // return x+y-z
  0x48064a              c3                      RET
```
从上面可以看到函数的参数也是通过堆栈进行传递，而不是像其他语言那样通过寄存器。
我们可以看到参数是在堆栈的顶部，而返回值则位于堆栈的底部。
**对比C和C++的汇编代码：**
```
FuncAdd:
      leal    (%rdi,%rsi), %eax
      subl    %edx, %eax
      retq
```
可以看到参数是通过寄存器进行传递。准确的数量依赖于调用约定，但是在freebsd/amd64下最多可以在寄存器中传递6个参数，其他的参数都必须在堆栈中。
注意：在go的公开提议中使用寄存器进行参数传递`https://github.com/golang/go/issues/18597`。但是没有被官方采纳。

### 函数的调用：一个函数是如何被调用的？
如何将上面的函数FuncAdd调用的？
```
func DoCallAdd() int { return FuncAdd(1, 2, 3) }
```
**汇编代码：**
```
0x480650              64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
0x480659              483b6110                CMPQ 0x10(CX), SP
0x48065d              7641                    JBE 0x4806a0
0x48065f              4883ec28                SUBQ $0x28, SP
0x480663              48896c2420              MOVQ BP, 0x20(SP)
0x480668              488d6c2420              LEAQ 0x20(SP), BP
0x48066d              48c7042401000000        MOVQ $0x1, 0(SP)
0x480675              48c744240802000000      MOVQ $0x2, 0x8(SP)
0x48067e              48c744241003000000      MOVQ $0x3, 0x10(SP)
0x480687              e8a4ffffff              CALL src.FuncAdd(SB)
0x48068c              488b442418              MOVQ 0x18(SP), AX
0x480691              4889442430              MOVQ AX, 0x30(SP)
0x480696              488b6c2420              MOVQ 0x20(SP), BP
0x48069b              4883c428                ADDQ $0x28, SP
0x48069f              c3                      RET
0x4806a0              e80ba5fcff              CALL runtime.morestack_noctxt(SB)
0x4806a5              eba9                    JMP src.DoCallAdd(SB)
```
这里有做了上面事情？
在这个函数的中心我们看到了我们想看到的：
```
0x48066d              48c7042401000000        MOVQ $0x1, 0(SP)     // set arg x
0x480675              48c744240802000000      MOVQ $0x2, 0x8(SP)   // set arg y
0x48067e              48c744241003000000      MOVQ $0x3, 0x10(SP)  // set arg z
0x480687              e8a4ffffff              CALL src.FuncAdd(SB) // call
0x48068c              488b442418              MOVQ 0x18(SP), AX    // get return value of FuncAdd
0x480691              4889442430              MOVQ AX, 0x30(SP)    // set return value of DoCallAdd
```
函数被调用之前，参数会被压栈，在被调用后，从被调用帧中检索返回值并复制到调用帧中。
但是，我们已经知道了函数在被调用的之前参数是会被压栈的，这个意味者其他函数要想调用其他函数的时候就必须确保有足够的栈空间来进行函数调用。下面的代码就是在腾出栈空间并恢复：
```
// Before the call: make space for callee.
0x48065f              4883ec28                SUBQ $0x28, SP
// After the call: restore stack pointer.
0x48069b              4883c428                ADDQ $0x28, SP
```
剩下的是什么呢？
由于go是存在panic的因此必须保持运行时系统展开堆栈的能力。对于每一个被激活记录中就必须保存他的入口的堆栈指针和被调用的堆栈指针之间的差异。这一类型的指针是被存放在BP寄存器中，正是我们看到的汇编代码：(这块说的就是恢复现场是如何做到的)
```
// Store the frame pointer of the caller into a known location in
// the current activation record.
0x480663              48896c2420              MOVQ BP, 0x20(SP)
// Store the address of the copy of the parent frame pointer
// into the new frame pointer.
0x480668              488d6c2420              LEAQ 0x20(SP), BP
```
这就是一个约定的格式，即BP中总是指向了一个帧指针的链表，其中BP的每一个连续值总是比当前帧（SP+0x20）的堆栈指针多32个字节。通过这种方式堆栈总是可以对成功的扩展。
最后一段代码又代表什么呢？
```
0x480650              64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
0x480659              483b6110                CMPQ 0x10(CX), SP
0x48065d              7641                    JBE 0x4806a0
...
0x4806a0              e80ba5fcff              CALL runtime.morestack_noctxt(SB)
0x4806a5              eba9                    JMP src.DoCallAdd(SB)
```
go的runtime使用小堆栈作为一个优化：这也意味者一个goroutine总是以一个最小的堆栈开始最小堆栈，因此在一个运行的go程序中是可以同时跑很多的goroutine














