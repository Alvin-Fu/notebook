[原文链接](https://dr-knz.net/go-calling-convention-x86-64.html)
## 简介：
本文分析go的编译器如何在x86-64目标中生成方法调用，参数传递和异常处理的代码。
这里没有分析编译器如何在内存中分配数据(函数的参数和返回值除外)、逃逸分析是怎么工作的、为什么编译器必须适应异步的垃圾回收器以及goroutine的处理如何影响代码的生成。
本文中的所有的代码都是使用freebsd/amd64目标go1.10.3执行的。汇编代码是使用`go tool objdump`生成的并且使用的是go的汇编语法。

## 参数、返回值和调用顺序
### 参数和返回值
**如何传递参数给函数并返回结果呢？**
让我们看一下这个简单的方法：
`func EmptyFunc() {}`
他的汇编代码：
```
EmptyFunc:
     0x480630              c3                      RET
```


在加一个返回值时：
`func EmptyFunc()int{	return 123 }`
他的汇编代码：
```
FuncConst:
  0x480630              48c74424087b000000      MOVQ $0x7b, 0x8(SP)
  0x480639              c3                      RET
```
对比汇编代码我们可以看到返回值是通过栈进行