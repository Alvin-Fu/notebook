# go调度的详解
## 概要
go的调度指的是goroutine的调度过程。和系统中的线程的调度有着相似的地方，我们先思考四个问题。
- 并行，可扩展且公平
- 每个进程应该可以扩展数百万个goroutine
- 内存利用率高
- 系统调用不应导致性能下降(最大吞吐量，最小化等待时间)
## goroutine调度程序模型
**一个线程执行一个goroutine局限性：**

- 并行可扩展(真并行假的可扩展)
- 每个进程不能扩展到数百万个goroutine

**M:N线程**
M个内核线程执行N个goroutine，内核线程的创建都是很昂贵的，因此是让goroutine去内核线程上运行。内核线程我们是不能控制的，但是goroutine的是可以控制的并且开销很小的。
内核不知道当前goroutine的状态，需要有一个调度器根据goroutine状态进行调度。与内核线程的状态信息比起来goroutin的保存的很少了，这个使得goroutine的切换开销很小
```text
- 正在运行(Running): 当前在内核线程上运行的goroutine
- 可运行()
```


















