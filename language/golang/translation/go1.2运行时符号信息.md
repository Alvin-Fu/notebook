[原文地址](https://docs.google.com/document/d/1lyPIbmsYbXnpNj57a261hgOYVpNRcgydurVQIyZOz_o/pub)
# go1.2运行时符号信息
## 摘要
在go1.2中将支持新的运行时符号。这个是内部的改变，不对用户可见的，但是他们删除了一些不稳定的代码，减少内存占用，使得gc的实现更加的简单。
## 背景
几年前，我为了获得准确的崩溃时的堆栈跟踪，我将plan9的符号和pcln表移动到运行时映射的内存中，并且将代码放到运行时的包中进行分析他们。除了栈追踪以外，栈的遍历功能现在被用于分析和垃圾回收。相对于之前是一个重大的改进，但是也是有一个严重的缺点：go程序首先要做的是花费时间和分配内存将那些表解码用于支持在栈遍历期间的各种格式的查询。在运行时有一条注释(on struct Func)说，最终这个符号表示应该接近这种格式。这样就可以直接读取表格，消除了启动和解码的内存成本。
这个方法还有其他问题：尴尬的在于从编译器到运行时获得新的元数据，因为他是以一种格式被发送到连接器，连接器在符号表中以第二种形式对其进行编码和运行时必须解码新的符号表扩展。Carl是有在添加垃圾回收的时候遇见他。Keith在几个月之前指出那是很混乱的。
## PC-Value表
在讨论我们的计划的细节之前，我们需要去引入pc-value表的概念，他是当前pcln表的泛化。pv-value表将程序计数器表示的代码位置映射到一个int32上。这个特殊的编码不是特别的重要，除了它可以被做的相当紧凑和易于在运行时解码。附件给出了一个示例。
pc-value表是有很多有趣的用法。最明显的是映射程序计数器到行号，但另一个用途就是生成一个pcsp表用于记录每一个程序计数器的堆栈帧的大小，因此堆栈展开总是可以确定当前帧在哪里结束，下一个帧在哪里开始。(事实上，有一些早期的Plan9连接器会生成这个表，但是在5I，6I和8I中是绝没有的。)另一个用途是编译器在每一个调用站点上记录栈变量的活性信息，使得gc可以忽略死栈槽。另一个用途就是让编译器记录哪一些寄存器中的值是需要被刷新到内存中，这样panic就可以适当的更新局部或全局变量。
## 提出的计划
该计划是用内存中的表单将当前的符号系统和pcln表替代，明确的设计被使用与go的运行时而不是任何的预处理。新的伪指令将使得定义每一个自定义函数的元数据和pc-vlue表，连接器是不用改变的。仅仅是编译器和运行时是需要被改变增加新的数据，并且这两者是不可避免的(编译器必须生成这些数据，运行时必须消费这些数据)。
具体来说，这个新函数符号表是一个程序计数器的查询表的形式：
`N pc0 func0 pc1 func1 pc2 func2 ... pc(N-1) func(N-1) pcN`
这个表是一个N的计数，后面一个

















