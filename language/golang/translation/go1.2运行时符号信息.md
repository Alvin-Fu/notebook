[原文地址](https://docs.google.com/document/d/1lyPIbmsYbXnpNj57a261hgOYVpNRcgydurVQIyZOz_o/pub)
# go1.2运行时符号信息
## 摘要
在go1.2中将支持新的运行时符号。这个是内部的改变，不对用户可见的，但是他们删除了一些不稳定的代码，减少内存占用，使得gc的实现更加的简单。
## 背景
几年前，我为了获得准确的崩溃时的堆栈跟踪，我将plan9的符号和pcln表移动到运行时映射的内存中，并且将代码放到运行时的包中进行分析他们。除了栈追踪以外，栈的遍历功能现在被用于分析和垃圾回收。相对于之前是一个重大的改进，但是也是有一个严重的缺点：go程序首先要做的是花费时间和分配内存将那些表解码用于支持在栈遍历期间的各种格式的查询。在运行时有一条注释(on struct Func)说，最终这个符号表示应该接近这种格式。这样就可以直接读取表格，消除了启动和解码的内存成本。
这个方法还有其他问题：尴尬的在于从编译器到运行时获得新的元数据，因为他是以一种格式被发送到连接器，连接器在符号表中以第二种形式对其进行编码和运行时必须解码新的符号表扩展。Carl是有在添加垃圾回收的时候遇见他。Keith在几个月之前指出那是很混乱的。
## PC-Value表
在讨论我们的计划的细节之前，我们需要去引入pc-value表的概念，他是当前pcln表的泛化。pv-value表将程序计数器表示的代码位置映射到一个int32上。这个特殊的编码不是特别的重要，除了它可以被做的相当紧凑和易于在运行时解码。附件给出了一个示例。
pc-value表是有很多有趣的用法。最明显的是映射程序计数器到行号，但另一个用途就是生成一个pcsp表用于记录每一个程序计数器的堆栈帧的大小，因此堆栈展开总是可以确定当前帧在哪里结束，下一个帧在哪里开始。(事实上，有一些早期的Plan9连接器会生成这个表)
















