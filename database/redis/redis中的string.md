# redis中的string结构
redis中的string的应用是很广泛的，他的实现方式也是比较特别的不是使用char数组实现的，而是通过SDS(Simple Dynamic String)实现的
## SDS介绍
SDS：简单动态字符串，使用c语言实现的。
```c
struct sdshdr{
    //记录buf数组已使用字节的数量
    //等于SDS所保存字符串的长度
    int length; 
    //记录buf数组未使用字节的数量
    int free;
    //buf数组
    char[] buf;
};
buf中会保留一个字节用于结尾，当free等于0的时候length是实际的buf长度减一，free不等于0的时候length+free等于buf的长度
```
## SDS和字符串的区别
c语言中的普通字符串不能满足redis的高效，安全，功能方面的需求
### 获取字符串的长度
**字符串**：由于字符串没有保存自己的长度，在获取的时候需要遍历O(N)
**SDS**: 由于保存了字符串的长度，这样就可以直接获取O(1)
这个就保证了获取字符串的长度不会成为redis的性能瓶颈
### 杜绝缓冲区溢出
**字符串**：字符串不能保证不溢出，由于char数组不能自动扩容很容易导致溢出的，当两个字符数组的内存很近的时候，这个时候如果在前一个的后面拼接一个比较大的数组容易将后面的数组覆盖掉
**SDS**：由于sds记录了当前的长度和空闲的，当长度不够的时候会进行扩展
### 空间预分配和惰性空间释放
当分配的时候会分配比实际需要的多减少连续曾长字符串带来的内存重新分配的开销
在字符串缩短的时候，SDS也不会立即回收不使用的空间，而是通过free将其记录下来，在后面使用的时候进行释放
预分配原则：当修改字符串的长度len小于1MB，则分配和len一样的长度的空间即len=free；若是len大于1MB就预分配1MB的空间
### 二进制安全
c语言的char数组是以空字符串结尾的，对于一些图片等包含结束符的就不是二进制安全的
sds是二进制安全的可以存储子符串和二进制文件(图片，音频等)

SDS的实现优点：

- 使用O(1)的时间复杂度获取字符串的长度
- 内置了使用长度和空闲的长度可以避免缓冲区溢出，并可以自动扩展
- 空间预分配和惰性释放，避免了频繁的扩展内存
- 由于没有特殊的字符用于结束，保证了数据安全(二进制安全)



















