# mysql的事务和锁
```
mysql的事务隔离级别一共有四个，读未提交，读已提交，可重复读和可串行化
```
## 事务
### 问题
脏读，幻读，不可重复读
#### 脏读
表示一个事务读到了另一个未提交事务修改过的数据。
事务A和事务B，当B修改了数据这事务还没提交的时候，A就读到了这个修改的数据，当B进行回滚的时候这个时候A就读到了不存在的数据。
脏读只会在读未提交隔离级别才会出现

#### 不可重复读
一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值
不可重复读在读未提交和读已提交隔离级别都可能会出现，主要是是对数据进行update操作
危害：会导致前后读取的数据不一致
解决：使用行级锁，锁定该行，事务A读取操作完成后才释放锁，这段时间不允许其他事务更改刚才的数据

#### 幻读
事务A在执行读取的时候，前一次和后一次读取到的数据总量不同，在两次读取的间隙另一个事务B进行了新增数据的操作，这个时候事务A在第二次读取的时候获取到数据量就和之前的不一样了，就好像幻觉一样，平白无故的多了几条数据
解决：使用表级锁，锁定整张表，当事务A多次读取执行完后才允许其他事务新增数据
幻读在读未提交，读已提交，可重复读隔离级别都会出现

**不可重复读和幻读的区别**

1. 不可重复读是读取了其他事务更改的数据，(update)
2. 幻读是读取了其他事务新增的数据(insert和update)

**发生的隔离级别**

|隔离级别|脏读|不可重复读|幻读|
|-|-|-|-|
|读未提交|可以|可以|可以|
|读已提交|不可以|可以|可以|
|可重复读|不可以|不可以|可以|
|可串行化|不可以|不可以|不可以|



### 数据库事务的四大特性

- 原子性：事务包含的所有数据库操作要么全部成功要么全部失败回滚
- 一致性：一个事务执行之前和执行之后都必须处于一致性状态(比如在转账中两个人前后的总和一定是相等的)
- 隔离性：一个事务未提交的业务结果是否对于其他事务可见，(四种隔离级别)
- 持久性：一个事务一旦被提交，那么对于数据库中数据的修改就是永久性的，即便数据库在遇到故障的情况下也不会丢失提交事务的操作

## 隔离级别
### 1、读未提交(Read uncommitted)
在事务没有最终提交的时候，这个数据已经是可见的了。(比如a给b转了100块钱，刚好b看到了，但是a突然发现转账错误了进行回滚，这时b实际的数额就没有刚才的100了)。
这个会导致脏读
### 2、读提交(Read committed)
事件B能读到事件A提交的数据，可以解决掉脏读的问题
一般数据库使用的是这个隔离级别
不能避免不可重复读和幻读
### 3、重复读（Repeatable read）
MySQL的默认隔离级别
这个级别可以保证修改同一条数据可以读取到一致的结果，但是不能保证插入和删除的时候拿到的总量是一致的
不能避免幻读
### 4、串行化(Serializable)
最高级别的隔离级别，花费的代价很高，性能很低，事务顺序执行，不会出现上面的三种问题。想·

## 隔离级别实现原理
使用MySQL的默认隔离级别是(可重复读)
可重复读的实现：
每条记录在更新的时候都会同时记录一条回滚操作(回滚操作日志undo log)。同一条记录在系统中可以存在多个版本，这个就是数据库的多版本并发控制(MVCC)。即通过回滚(rollback操作)可以回到前一个状态。
事务在每个版本中都是有row trx_id,事务根据undo log和trx_id构建出满足当前隔离级别的一致性试图。

**在InnoDB中update时都是先读后写，这个读只能读当前值(称为“当前读”)**
**当前读：**当前读时会使用行锁
**快照读：**基于版本的读，这时不会加锁，可能会造成幻读

事务在更新的时候会使用行锁，对该行数据加锁直到事务结束。
## 锁
两种类型悲观锁和乐观锁
### 悲观锁
表示对于数据被外部修改持保守态度(包括本系统的事务和外部系统事务的处理)，在整个数据处理过程中将数据处于锁定状态。
悲观锁的实现依靠了数据库提供的锁机制(只有数据库层提供的锁机制才能真正的保证数据访问的排他性)
在悲观锁的情况下，为了保证事务的隔离性，读写都会进行加锁。
在大多数情况下使用的是数据库的锁机制，用以保证独占性，这样使得数据库的开销变大，在某写长事务下这种开销是灾难性的。
### 乐观锁
相对于悲观锁乐观锁的加锁机制相对宽松。大多数的乐观锁是基于数据版本记录机制实现。
一般会在表中添加一个version字段，在更新的时候对比版本号，大于则更新，小于则认为是过期数据。
### MVCC(多版本并发控制)
这是以乐观锁为理论基础的，不同的数据库都有不同的实现方式
mysql中默认的事务隔离级别是可重复读(repeatable-read)，InnoDB中使用的MVCC实现的
MVCC利用在每条数据中加了两个隐藏列(创建版本号和删除版本号)，每个事务在开始的时候都会有一个递增的版本号。
主要作用于事务性的，有行锁控制的数据库模型。

### mysql中不同粒度的锁
|级别|并发性|锁的力度|开销|是否死锁|适用场景|
|-|-|-|-|-|-|
|表锁|低|大|小|否|查询为主，并发量小，一些web应用|
|页面锁|适中|适中|适中|是||
|行级锁|高|小|大|是|大多数情况|

#### 行级锁
**实现**
- InnoDB是通过给索引上的索引项加锁来实现的(意味着只有通过索引条件的时候才会使用行锁，否则就是表锁)。Oracle是通过给数据块中相应的数据行加锁的。
- 只要使用索引，InnoDB都会对数据加行锁
- 只有执行计划真正使用了索引，才会使用行锁。(可以通过explain来查看sql的执行计划)
- 由于行锁是通过索引添加的，如果其他session用到其中的索引将会等待

间隙锁：在对范围操作时，对于整个范围进行加锁，这样可以避免出现幻读，但是会出现性能问题，导致刚好在该范围的操作进入等待。因此在业务上尽量多的使用等号

## 参考
[搞懂事务隔离级别](https://developer.aliyun.com/article/743691)
[快速理解脏读等](https://cloud.tencent.com/developer/article/1450773)
[可重复读的实现](https://juejin.cn/post/6844904180440629262)




















