# mysql的事务和锁
```
mysql的事务隔离级别一共有四个，读未提交，读已提交，可重复读和可串行化
```
## 事务
### 问题
脏读，幻读，不可重复读
#### 脏读
表示一个事务读到了另一个未提交事务修改过的数据。
事务A和事务B，当B修改了数据这事务还没提交的时候，A就读到了这个修改的数据，当B进行回滚的时候这个时候A就读到了不存在的数据。
脏读只会在读未提交隔离级别才会出现

#### 不可重复读
一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值
不可重复读在读未提交和读已提交隔离级别都可能会出现，主要是是对数据进行update操作
危害：会导致前后读取的数据不一致
解决：使用行级锁，锁定该行，事务A读取操作完成后才释放锁，这段时间不允许其他事务更改刚才的数据

#### 幻读
事务A在执行读取的时候，前一次和后一次读取到的数据总量不同，在两次读取的间隙另一个事务B进行了新增数据的操作，这个时候事务A在第二次读取的时候获取到数据量就和之前的不一样了，就好像幻觉一样，平白无故的多了几条数据
解决：使用表级锁，锁定整张表，当事务A多次读取执行完后才允许其他事务新增数据
幻读在读未提交，读已提交，可重复读隔离级别都会出现

**不可重复读和幻读的区别**

1. 不可重复读是读取了其他事务更改的数据，(update)
2. 幻读是读取了其他事务新增的数据(insert和update)

**发生的隔离级别**

|隔离级别|脏读|不可重复读|幻读|
|-|-|-|-|
|读未提交|可以|可以|可以|
|读已提交|不可以|可以|可以|
|可重复读|不可以|不可以|可以|
|可串行化|不可以|不可以|不可以|



### 数据库事务的四大特性

- 原子性：事务包含的所有数据库操作要么全部成功要么全部失败回滚
- 一致性：一个事务执行之前和执行之后都必须处于一致性状态(比如在转账中两个人前后的总和一定是相等的)
- 隔离性：一个事务未提交的业务结果是否对于其他事务可见，(四种隔离级别)
- 持久性：一个事务一旦被提交，那么对于数据库中数据的修改就是永久性的，即便数据库在遇到故障的情况下也不会丢失提交事务的操作

## 隔离级别
### 1、读未提交(Read uncommitted)
在事务没有最终提交的时候，这个数据已经是可见的了。(比如a给b转了100块钱，刚好b看到了，但是a突然发现转账错误了进行回滚，这时b实际的数额就没有刚才的100了)。
这个会导致脏读
### 2、读提交(Read committed)
事件B能读到事件A提交的数据，可以解决掉脏读的问题
一般数据库使用的是这个隔离级别
不能避免不可重复读和幻读
### 3、重复读（Repeatable read）
MySQL的默认隔离级别
这个级别可以保证修改同一条数据可以读取到一致的结果，但是不能保证插入和删除的时候拿到的总量是一致的
不能避免幻读
### 4、串行化(Serializable)
最高级别的隔离级别，花费的代价很高，性能很低，事务顺序执行，不会出现上面的三种问题。

## 锁
两种类型悲观锁和乐观锁
### 悲观锁
### 乐观锁
### MVCC(多版本并发控制)













